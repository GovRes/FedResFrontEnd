import { fetchAuthSession } from "aws-amplify/auth";
import {
  AwardType,
  EducationType,
  SpecializedExperienceType,
  PastJobType,
  ResumeType,
} from "../utils/responseSchemas";
import { generateClient } from "aws-amplify/api";

/**
 * Types for different associations - updated to match responseSchemas
 */
type AssociationType =
  | "Award"
  | "Education"
  | "SpecializedExperience"
  | "PastJob"
  | "Resume";

type AssociationTypeMap = {
  Award: AwardType;
  Education: EducationType;
  SpecializedExperience: SpecializedExperienceType;
  PastJob: PastJobType;
  Resume: ResumeType;
};
export const associateItemsWithApplication = async ({
  applicationId,
  items,
  associationType,
}: {
  applicationId: string;
  items: { id: string }[] | string[];
  associationType: AssociationType;
}) => {
  try {
    const session = await fetchAuthSession();
    if (!session.tokens) {
      throw new Error("No valid authentication session found");
    }
  } catch (error) {
    console.error("No user is signed in");
    return;
  }

  const client = generateClient();

  try {
    // Validate required parameters
    if (!applicationId || !items || items.length === 0) {
      throw new Error(
        `applicationId and non-empty ${associationType} items array are required`
      );
    }

    // Map to get the item IDs whether we received objects with IDs or just ID strings
    const itemIds = items.map((item) =>
      typeof item === "string" ? item : item.id
    );

    // Build the mutation name based on the associationType
    const mutationName = `create${associationType}Application`;

    // Build the input field name based on the associationType (lowercase first letter)
    const itemIdFieldName = `${
      associationType.charAt(0).toLowerCase() + associationType.slice(1)
    }Id`;

    // Create connections one at a time to avoid complex filter expressions
    const createdConnections = [];

    for (const itemId of itemIds) {
      const input = {
        [itemIdFieldName]: itemId,
        applicationId,
      };

      const response = await client.graphql({
        query: `
          mutation Create${associationType}Application($input: Create${associationType}ApplicationInput!) {
            ${mutationName}(input: $input) {
              id
              ${itemIdFieldName}
              applicationId
            }
          }
        `,
        variables: { input },
        authMode: "userPool",
      });

      if ("data" in response) {
        createdConnections.push(response.data[mutationName]);
      } else {
        throw new Error(
          `Unexpected response format from GraphQL operation for ${associationType}`
        );
      }
    }
    return createdConnections;
  } catch (error) {
    console.error(
      `Error associating ${associationType} with Application:`,
      error
    );
    throw error;
  }
};

export const createAndSaveApplication = async ({
  jobId,
  userId,
}: {
  jobId: string;
  userId: string;
}) => {
  try {
    const session = await fetchAuthSession();
    if (!session.tokens) {
      throw new Error("No valid authentication session found");
    }
  } catch (error) {
    console.error("No user is signed in");
    // Redirect to login page
    return;
  }
  const client = generateClient();
  try {
    // Validate required parameters
    if (!jobId || !userId) {
      throw new Error("jobId and userId are required parameters");
    }

    // Create the Application input object
    const applicationInput = {
      jobId,
      userId,
      // Note: The ID will be auto-generated by Amplify
    };

    // Use the client.models approach in Amplify v2
    const response = await client.graphql({
      query: `
        mutation CreateApplication($input: CreateApplicationInput!) {
          createApplication(input: $input) {
            id
            jobId
            userId
            createdAt
            updatedAt
          }
        }
      `,
      variables: {
        input: applicationInput,
      },
      authMode: "userPool",
    });

    // Return the created Application
    if ("data" in response) {
      return response.data.createApplication;
    }
    throw new Error("Unexpected response format from GraphQL operation");
  } catch (error) {
    console.error("Error creating Application:", error);
    throw error;
  }
};
function deduplicateById<T extends { id: string }>(items: T[]): T[] {
  const seen = new Set<string>();
  return items.filter((item) => {
    if (seen.has(item.id)) {
      return false;
    }
    seen.add(item.id);
    return true;
  });
}

/**
 * Get all associations of a specific type for an application
 *
 * @param {Object} params - The function parameters
 * @param {string} params.applicationId - The ID of the application
 * @param {AssociationType} params.associationType - The type of association to fetch
 * @returns {Promise<T[]>} - Array of associated items with duplicates removed
 * @throws {Error} - If fetching fails or required parameters are missing
 */
export const getApplicationAssociations = async <T extends AssociationType>({
  applicationId,
  associationType,
}: {
  applicationId: string;
  associationType: T;
}): Promise<AssociationTypeMap[T][] | undefined> => {
  try {
    const session = await fetchAuthSession();
    if (!session.tokens) {
      throw new Error("No valid authentication session found");
    }
  } catch (error) {
    console.error("No user is signed in");
    return;
  }

  const client = generateClient();

  try {
    // Validate required parameters
    if (!applicationId) {
      throw new Error("applicationId is required");
    }

    // Build the query name based on the associationType
    const queryName = `list${associationType}Applications`;

    // Build the filter to match the applicationId
    const filter = {
      applicationId: { eq: applicationId },
    };

    // Define the fields to fetch based on the associationType
    const getSpecificFields = () => {
      switch (associationType) {
        case "Award":
          return `
            title
            date
            userId
          `;
        case "Education":
          return `
            degree
            major
            school
            schoolCity
            schoolState
            date
            title
            gpa
            userConfirmed
            userId
          `;
        case "SpecializedExperience":
          return `
            title
            description
            userConfirmed
            paragraph
            initialMessage
            typeOfExperience
            userId
          `;
        case "PastJob":
          return `
            endDate
            hours
            organization
            organizationAddress
            supervisorMayContact
            supervisorName
            supervisorPhone
            type
            qualifications {
              items {
                id
                qualificationId
                qualification {
                  id
                  title
                  description
                  paragraph
                  question
                  userConfirmed
                  userId
                  topic {
                    id
                    title
                    jobId
                    keywords
                    description
                    evidence
                  }
                }
              }
            }
            gsLevel
            responsibilities
            startDate
            title
            userId
          `;
        case "Resume":
          return `
            fileName
            userId
          `;
        default:
          return "";
      }
    };

    // Execute the query to get the junction table entries
    const junctionResponse = await client.graphql({
      query: `
        query List${associationType}Applications($filter: Model${associationType}ApplicationFilterInput) {
          ${queryName}(filter: $filter) {
            items {
              id
              applicationId
              ${
                associationType.charAt(0).toLowerCase() +
                associationType.slice(1)
              }Id
              ${
                associationType.charAt(0).toLowerCase() +
                associationType.slice(1)
              } {
                id
                ${getSpecificFields()}
                createdAt
                updatedAt
              }
              createdAt
              updatedAt
            }
          }
        }
      `,
      variables: { filter } as any,
      authMode: "userPool",
    });

    if ("data" in junctionResponse) {
      // Extract associated items
      const junctionItems = junctionResponse.data[queryName].items;
      const associatedItemsWithDuplicates = junctionItems
        .map(
          (item: any) =>
            item[
              associationType.charAt(0).toLowerCase() + associationType.slice(1)
            ]
        )
        .filter(Boolean); // Filter out any null items

      // Deduplicate by ID
      const uniqueItems = deduplicateById(associatedItemsWithDuplicates);

      // Special handling for PastJob and Volunteer to transform the data structure
      if (associationType === "PastJob") {
        return uniqueItems.map((item: any) => {
          // Convert hours to string if it's a number to match schema
          const hours =
            item.hours !== undefined ? String(item.hours) : undefined;

          return {
            ...item,
            hours,
            // Format qualifications as an array matching the schema
            qualifications: (item.qualifications?.items || []).map(
              (qualJunction: any) => {
                // Get the actual qualification from the junction object
                const qual = qualJunction.qualification || {};

                return {
                  id: qual.id || qualJunction.id || "",
                  title: qual.title || "",
                  description: qual.description || "",
                  paragraph: qual.paragraph,
                  question: qual.question,
                  userConfirmed: qual.userConfirmed || false,
                  userId: qual.userId || item.userId,
                  topic: qual.topic
                    ? {
                        id: qual.topic.id || "",
                        title: qual.topic.title || "",
                        jobId: qual.topic.jobId || "",
                        keywords: qual.topic.keywords || [],
                        description: qual.topic.description,
                        evidence: qual.topic.evidence,
                        question: qual.question,
                      }
                    : {
                        id: "",
                        title: "",
                        jobId: "",
                        keywords: [],
                      },
                };
              }
            ),
          };
        }) as AssociationTypeMap[T][];
      }

      return uniqueItems as AssociationTypeMap[T][];
    }

    throw new Error(
      `Unexpected response format from GraphQL operation for ${associationType}`
    );
  } catch (error) {
    console.error(
      `Error fetching ${associationType} associations for Application:`,
      error
    );
    throw error;
  }
};
export const getApplicationWithJob = async ({ id }: { id: string }) => {
  try {
    const session = await fetchAuthSession();
    if (!session.tokens) {
      throw new Error("No valid authentication session found");
    }
  } catch (error) {
    console.error("No user is signed in");
    return;
  }
  const client = generateClient();
  try {
    const response = await client.graphql({
      query: `
      query GetApplication($id: ID!) {
        getApplication(id: $id) {
        completedSteps
        id
        jobId
        userId
        job {
          id
          title
          department
          agencyDescription
          duties
          evaluationCriteria
          qualificationsSummary
          questionnaire
          requiredDocuments
          usaJobsId
          topics {
            items {
              id
              keywords
              title
            }
          }
        }
        createdAt
        updatedAt
        }
      }
      `,
      variables: { id },
      authMode: "userPool",
    });

    if ("data" in response) {
      const application = response.data.getApplication;

      // Flatten the topics.items array if it exists
      if (application?.job?.topics?.items) {
        application.job.topics = application.job.topics.items;
      }

      return application;
    }
    throw new Error("Unexpected response format from GraphQL operation");
  } catch (error) {
    console.error("Error fetching Application:", error);
    throw error;
  }
};
export const listApplications = async () => {
  try {
    const session = await fetchAuthSession();
    if (!session.tokens) {
      throw new Error("No valid authentication session found");
    }
  } catch (error) {
    console.error("No user is signed in");
    return;
  }

  const client = generateClient();
  try {
    const response = await client.graphql({
      query: `
        query ListApplications {
          listApplications {
            items {
              id
              jobId
              userId
              createdAt
              updatedAt
            }
          }
        }
      `,
      authMode: "userPool",
    });

    if ("data" in response) {
      return response.data.listApplications.items;
    }
    throw new Error("Unexpected response format from GraphQL operation");
  } catch (error) {
    console.error("Error fetching Applications:", error);
    throw error;
  }
};

export const listUserApplications = async ({ userId }: { userId: string }) => {
  try {
    const session = await fetchAuthSession();
    if (!session.tokens) {
      throw new Error("No valid authentication session found");
    }
  } catch (error) {
    console.error("No user is signed in");
    return;
  }

  const client = generateClient();
  try {
    // Validate required parameter
    if (!userId) {
      throw new Error("userId is required");
    }

    const response = await client.graphql({
      query: `
        query ListApplications($filter: ModelApplicationFilterInput) {
          listApplications(filter: $filter) {
            items {
              id
              jobId
              userId
              job {
                id
                title
                department
                agencyDescription
              }
              createdAt
              updatedAt
            }
          }
        }
      `,
      variables: {
        filter: {
          userId: { eq: userId },
        },
      },
      authMode: "userPool",
    });

    if ("data" in response) {
      return response.data.listApplications.items;
    }
    throw new Error("Unexpected response format from GraphQL operation");
  } catch (error) {
    console.error("Error fetching user Applications:", error);
    throw error;
  }
};
export const updateApplication = async ({
  id,
  input,
}: {
  id: string;
  input: {
    completedSteps?: string[];
  };
}) => {
  try {
    const session = await fetchAuthSession();
    if (!session.tokens) {
      throw new Error("No valid authentication session found");
    }
  } catch (error) {
    console.error("No user is signed in");
    return;
  }

  const client = generateClient();

  try {
    // Validate required parameters
    if (!id) {
      throw new Error("Application id is required");
    }

    if (Object.keys(input).length === 0) {
      throw new Error("At least one field to update is required");
    }

    const response = await client.graphql({
      query: `
        mutation UpdateApplication($input: UpdateApplicationInput!) {
          updateApplication(input: $input) {
            id
          }
        }
      `,
      variables: {
        input: {
          id,
          ...input,
        },
      },
      authMode: "userPool",
    });

    if ("data" in response) {
      return response.data.updateApplication;
    }

    throw new Error("Unexpected response format from GraphQL operation");
  } catch (error) {
    console.error("Error updating Application:", error);
    throw error;
  }
};
/**
 * Helper function to deduplicate an array of objects by ID
 *
 * @param {Array<{id: string}>} items - Array of objects with id property
 * @returns {Array<{id: string}>} - Array with duplicates removed
 */

/**
 * Deletes an Application and all its associated join table entries
 * without deleting the actual associated items (Education, Award, etc.)
 *
 * @param {Object} params - The function parameters
 * @param {string} params.applicationId - The ID of the application to delete
 * @returns {Promise<any>} - The deleted application data
 * @throws {Error} - If deletion fails or required parameters are missing
 */
export const deleteApplication = async ({
  applicationId,
}: {
  applicationId: string;
}) => {
  try {
    const session = await fetchAuthSession();
    if (!session.tokens) {
      throw new Error("No valid authentication session found");
    }
  } catch (error) {
    console.error("No user is signed in");
    return;
  }

  const client = generateClient();

  try {
    // Validate required parameter
    if (!applicationId) {
      throw new Error("applicationId is required");
    }

    // Define the join tables that need to be cleaned up
    const joinTables = [
      "AwardApplication",
      "EducationApplication",
      "ResumeApplication",
      "SpecializedExperienceApplication",
      "PastJobApplication",
    ];

    // Step 1: Delete all join table entries for each association type
    // Use Promise.all to wait for all join table deletions to complete
    await Promise.all(
      joinTables.map(async (joinTable) => {
        // 1.1: List all join table entries for this application
        const listQuery = `
          query List${joinTable}s($filter: Model${joinTable}FilterInput) {
            list${joinTable}s(filter: $filter) {
              items {
                id
              }
            }
          }
        `;

        const listResponse = await client.graphql({
          query: listQuery,
          variables: {
            filter: {
              applicationId: { eq: applicationId },
            },
          },
          authMode: "userPool",
        });

        if (
          "data" in listResponse &&
          listResponse.data[`list${joinTable}s`]?.items
        ) {
          const joinItems = listResponse.data[`list${joinTable}s`].items;

          // 1.2: Delete each join table entry - use Promise.all here too
          await Promise.all(
            joinItems.map(async (item: any) => {
              const deleteQuery = `
                mutation Delete${joinTable}($input: Delete${joinTable}Input!) {
                  delete${joinTable}(input: $input) {
                    id
                  }
                }
              `;

              return client.graphql({
                query: deleteQuery,
                variables: {
                  input: { id: item.id },
                },
                authMode: "userPool",
              });
            })
          );
        }
      })
    );

    // Step 2: Now that all join table entries are deleted, delete the application itself
    const deleteApplicationQuery = `
      mutation DeleteApplication($input: DeleteApplicationInput!) {
        deleteApplication(input: $input) {
          id
          jobId
          userId
          createdAt
          updatedAt
        }
      }
    `;

    const deleteResponse = await client.graphql({
      query: deleteApplicationQuery,
      variables: {
        input: { id: applicationId },
      },
      authMode: "userPool",
    });

    if ("data" in deleteResponse) {
      return deleteResponse.data.deleteApplication;
    }

    throw new Error("Unexpected response format from GraphQL operation");
  } catch (error) {
    console.error("Error deleting Application:", error);
    throw error;
  }
};

/**
 * Helper function to delete a single item from a join table
 *
 * @param {Object} params - The function parameters
 * @param {string} params.id - The ID of the join table entry to delete
 * @param {string} params.tableName - The name of the join table (e.g., "AwardApplication")
 * @returns {Promise<any>} - The deleted join table entry data
 * @throws {Error} - If deletion fails
 */
export const deleteJoinTableItem = async ({
  id,
  tableName,
}: {
  id: string;
  tableName: string;
}) => {
  try {
    const session = await fetchAuthSession();
    if (!session.tokens) {
      throw new Error("No valid authentication session found");
    }
  } catch (error) {
    console.error("No user is signed in");
    return;
  }

  const client = generateClient();

  try {
    const deleteQuery = `
      mutation Delete${tableName}($input: Delete${tableName}Input!) {
        delete${tableName}(input: $input) {
          id
        }
      }
    `;

    const response = await client.graphql({
      query: deleteQuery,
      variables: {
        input: { id },
      },
      authMode: "userPool",
    });

    if ("data" in response) {
      return response.data[`delete${tableName}`];
    }

    throw new Error(
      `Unexpected response format from GraphQL operation when deleting ${tableName}`
    );
  } catch (error) {
    console.error(`Error deleting ${tableName}:`, error);
    throw error;
  }
};
